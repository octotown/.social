name: Feed Sync

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write

jobs:
  sync-feed:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run feed sync
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          #!/bin/bash
          set -e

          # Configuration
          FEED_DIR="./feed"
          ARCHIVE_DIR="./feed/archive"
          LAST_FILE="./feed/.last"
          FOLLOWING_DIR="./following"
          BLOCKED_DIR="./blocked"
          DAYS_TO_KEEP=7

          # Ensure directories exist
          mkdir -p "$FEED_DIR" "$ARCHIVE_DIR"

          # Get last sync timestamp (default to 7 days ago)
          if [ -f "$LAST_FILE" ]; then
            LAST_SYNC=$(cat "$LAST_FILE")
          else
            LAST_SYNC=$(date -u -d "7 days ago" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u -v-7d +"%Y-%m-%dT%H:%M:%SZ")
          fi

          echo "Last sync: $LAST_SYNC"

          # Get repository owner (current user)
          REPO_OWNER=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1)
          echo "Repository owner: $REPO_OWNER"

          # Get list of blocked users
          BLOCKED_USERS=""
          if [ -d "$BLOCKED_DIR" ]; then
            BLOCKED_USERS=$(ls "$BLOCKED_DIR" 2>/dev/null | tr '\n' '|' | sed 's/|$//')
          fi

          # Build list of users to fetch (owner + following)
          USERS_TO_FETCH="$REPO_OWNER"
          for user_file in "$FOLLOWING_DIR"/*; do
            if [ -f "$user_file" ]; then
              user=$(basename "$user_file")
              # Skip if blocked
              if [ -n "$BLOCKED_USERS" ] && echo "$user" | grep -qE "^($BLOCKED_USERS)$"; then
                echo "Skipping blocked user: $user"
                continue
              fi
              USERS_TO_FETCH="$USERS_TO_FETCH $user"
            fi
          done

          # Process owner and each followed user
          for user in $USERS_TO_FETCH; do
            echo "Fetching posts from: $user"
            
            # Fetch issues from user's .social repo
            response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$user/.social/issues?since=$LAST_SYNC&state=open&sort=created&direction=desc&per_page=100")
            
            # Check if response is valid
            if echo "$response" | jq -e 'type == "array"' > /dev/null 2>&1; then
              echo "$response" | jq -c '.[]' | while read -r issue; do
                title=$(echo "$issue" | jq -r '.title')
                id=$(echo "$issue" | jq -r '.number')
                created_at=$(echo "$issue" | jq -r '.created_at')
                body=$(echo "$issue" | jq -r '.body // ""')
                url=$(echo "$issue" | jq -r '.html_url')
                
                # Determine post type
                if [[ "$title" == post:* ]]; then
                  post_type="post"
                  content="${title#post: }"
                elif [[ "$title" == repost:* ]]; then
                  repost_url="${title#repost: }"
                  
                  # Check if it's a quote or pure repost
                  if [ -z "$body" ] || [ "$body" == "null" ]; then
                    post_type="repost"
                  else
                    post_type="quote"
                  fi
                  content="$repost_url"
                  
                  # Resolve to original post
                  if [[ "$repost_url" =~ ^https://github\.com/([^/]+)/\.social/issues/([0-9]+)$ ]]; then
                    orig_user="${BASH_REMATCH[1]}"
                    orig_id="${BASH_REMATCH[2]}"
                    
                    # Fetch original issue (with chain resolution)
                    orig_response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                      -H "Accept: application/vnd.github.v3+json" \
                      "https://api.github.com/repos/$orig_user/.social/issues/$orig_id")
                    
                    orig_title=$(echo "$orig_response" | jq -r '.title // ""')
                    orig_created=$(echo "$orig_response" | jq -r '.created_at // ""')
                    orig_url=$(echo "$orig_response" | jq -r '.html_url // ""')
                    
                    # Follow chain if original is also a repost
                    while [[ "$orig_title" == repost:* ]]; do
                      chain_url="${orig_title#repost: }"
                      if [[ "$chain_url" =~ ^https://github\.com/([^/]+)/\.social/issues/([0-9]+)$ ]]; then
                        orig_user="${BASH_REMATCH[1]}"
                        orig_id="${BASH_REMATCH[2]}"
                        
                        orig_response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                          -H "Accept: application/vnd.github.v3+json" \
                          "https://api.github.com/repos/$orig_user/.social/issues/$orig_id")
                        
                        orig_title=$(echo "$orig_response" | jq -r '.title // ""')
                        orig_created=$(echo "$orig_response" | jq -r '.created_at // ""')
                        orig_url=$(echo "$orig_response" | jq -r '.html_url // ""')
                      else
                        break
                      fi
                    done
                    
                    if [[ "$orig_title" == post:* ]]; then
                      original_content="${orig_title#post: }"
                    else
                      original_content="$orig_title"
                    fi
                  fi
                else
                  # Skip malformed posts
                  echo "Skipping malformed post: $title"
                  continue
                fi
                
                # Generate filename (replace colons in timestamp for filesystem safety)
                safe_timestamp=$(echo "$created_at" | sed 's/:/-/g' | sed 's/\.[0-9]*Z$/Z/')
                filename="${safe_timestamp}-${user}-${id}.md"
                filepath="$FEED_DIR/$filename"
                
                # Skip if already exists
                if [ -f "$filepath" ] || [ -f "$ARCHIVE_DIR/$filename" ]; then
                  echo "Skipping existing post: $filename"
                  continue
                fi
                
                echo "Creating feed file: $filename"
                
                # Create feed file with frontmatter
                {
                  echo "---"
                  echo "id: $id"
                  echo "author: $user"
                  echo "timestamp: $created_at"
                  echo "type: $post_type"
                  echo "url: $url"
                  
                  if [ "$post_type" != "post" ] && [ -n "$orig_user" ]; then
                    echo "original_author: $orig_user"
                    echo "original_id: $orig_id"
                    echo "original_url: $orig_url"
                    echo "original_timestamp: $orig_created"
                  fi
                  
                  echo "---"
                  
                  if [ "$post_type" == "post" ]; then
                    echo "$content"
                  elif [ "$post_type" == "quote" ]; then
                    # First 250 chars of body as quote
                    echo "${body:0:250}"
                    echo ""
                    echo "> $original_content"
                  else
                    echo "> $original_content"
                  fi
                } > "$filepath"
              done
            else
              echo "Failed to fetch issues for $user or no issues found"
            fi
          done

          # Archive old posts (older than 7 days)
          echo "Archiving old posts..."
          cutoff_date=$(date -u -d "$DAYS_TO_KEEP days ago" +"%Y-%m-%dT%H-%M-%SZ" 2>/dev/null || date -u -v-${DAYS_TO_KEEP}d +"%Y-%m-%dT%H-%M-%SZ")
          
          for file in "$FEED_DIR"/*.md; do
            if [ ! -f "$file" ]; then
              continue
            fi
            
            filename=$(basename "$file")
            # Extract timestamp from filename (first part before the username)
            file_timestamp=$(echo "$filename" | grep -oE '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}-[0-9]{2}-[0-9]{2}Z')
            
            if [ -n "$file_timestamp" ] && [[ "$file_timestamp" < "$cutoff_date" ]]; then
              echo "Archiving: $filename"
              mv "$file" "$ARCHIVE_DIR/"
            fi
          done

          # Update last sync timestamp
          date -u +"%Y-%m-%dT%H:%M:%SZ" > "$LAST_FILE"
          echo "Updated last sync timestamp"

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitSocial Bot"
          git add feed/
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Sync feed $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
            git push
          fi
